#769 175 742

##回顾

+ 表单指令 v-model
+ 修饰符
+ 生命周期


##监听属性

Vue提供了watch选项，提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。


定义在watch 对象中

+ 函数写法 （浅监听）  有两个参数
+ 对象写法  (深监听）   handler 函数  deep 属性
+ 监听属性的名称 一定是data 内定义过的数据名称
+ 关联的data 发生变化时 监听函数就会执行，函数内部的代码不做限制
+ 一个监听属性关联一个值



##计算属性

computed 对象中

+ 函数式写法
+ 对象写法  set&&get
+ 监听属性的名称 一定不能data 内定义过的数据名称
+ 关联的data 发生变化时 函数就会执行，函数内部必须有返回值
+ 一个计算属性可以关联多个个值
+ 如果依赖的数据不更新，则读取缓存，不会重新计算。






+ 计算属性和methods的区别
相同点：将计算价格定义为一个方法而不是一个计算属性，两种方式得到的结果是相同的
不同点：
  计算属性是基于变量的值进行缓存的，只要在它关联的变量值发生变化时计算属性就会重新执行；
  methods没有缓存，所以每次访问都要重新执行





计算属性和watch的区别
相同点：
都是以Vue的依赖追踪机制为基础的，都是希望在依赖数据发生改变的时候，被依赖的数据根据预先定义好的函数，发生“自动”的变化
   

不同点：
    - watch擅长处理的场景：一个数据影响多个数据
    - computed擅长处理的场景：一个数据受多个数据影响
   

总结：
当在模板内使用了复杂逻辑的表达式时，应当使用计算属性
虽然方法也能实现同样的效果，但是因为计算属性可以基于它们的依赖进行缓存，所以选择计算属性会比方法更优
当需要在数据变化时执行异步或开销较大的操作时，可以使用 watch


##过滤器：

全局定义的过滤器，所有实例都可以使用
        
	Vue.filter("upper",(val)=>{
            return  val.charAt(0).toUpperCase()+ val.slice(1);
        })



局部定义过滤器

	let vm = new Vue({
            el:"#app",
            data:{
                price:200,
                price1:299,
                msg:"helloworld",
                d:Date.now()
            },
            // 局部定义过滤器，只有当前实例可以使用
            filters:{
                // 过滤器 函数的第一个参数 是被过滤的数据
                // 第二参数开始才是过滤器接受的参数
                changeToPrice(val){
                    // 经过过滤后最终的文本
                    return "￥：" + val;
                },
                upper1(val,n){
                    console.log(n)
                    return  val.slice(0,n)+val.charAt(n).toUpperCase()+ val.slice(n+1);
                }
            },
            methods: {
                
            },
        })



##过渡：

###Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡

条件渲染 (使用 v-if)
条件展示 (使用 v-show)
动态组件
组件根节点

###当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理：

自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。

如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。

如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 nextTick 概念不同)



###在进入/离开的过渡中，会有 6 个 class 切换。

v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。

v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。

v-enter-to：2.1.8 版及以上定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。

v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。

v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。

v-leave-to：2.1.8 版及以上定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。


##


		[Vue warn]: The computed property "newMsg" is already defined in data.
		
		(found in <Root>)

		计算属性 已经在data 中有同名的data 了
	